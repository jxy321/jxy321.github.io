# 常见服务器故障处理策略

#### 一、必须搞清楚的问题有：

故障的表现是什么?无响应?报错?

故障是什么时候发现的?

故障是否可重现?

有没有出现的规律(比如每小时出现一次)

最后一次对整个平台进行更新的内容是什么(代码、服务器等)?

故障影响的特定用户群是什么样的(已登录的,退出的,某个地域的…)?

基础架构(物理的、逻辑的)的文档是否能找到?

是否有监控平台可用?

是否有日志可以查看?

最后两个是最方便的信息来源，特别是日志系统,作为运维人员要善于和擅长查看日志,日志往往是你在没有头绪的时候给你最大的帮助,其实很多问题都在日志系统中暴露出来,比较方便的是使用系统笔记

#### 二、有谁在?

```bash
w [选项]
#用于显示当前登录系统的用户信息和活动的 Linux 命令。它会显示登录用户的用户名、登录时间、登录终端或远程连接的来源、登录时长以及用户当前的活动状态

w           # 显示当前登录用户的信息
w -h        # 隐藏表头显示用户信息
w -s        # 显示简要的用户信息
w -f        # 显示用户登录来源
w -u        # 显示用户空闲时间
w -i        # 显示用户的 IP 地址
```

```bash
last
last [选项] [用户名]
#用于显示系统上的登录记录和登录用户的相关信息。它会显示最近登录到系统的用户列表，包括登录用户名、登录时间、登录来源（终端或远程连接）、注销时间以及登录持续时间等信息.

last                     # 显示所有用户的登录记录
last -n 10               # 显示最近10个登录记录
last -f /var/log/wtmp    # 显示指定日志文件的登录记录
last username            # 显示指定用户的登录记录
last -i                  # 显示登录 IP 地址
last -t                  # 按时间顺序显示登录记录
```

用这两个命令看看都有谁在线，有哪些用户访问过。这不是什么关键步骤，不过最好别在其他用户正干活的时候来调试系统。有道是一山不容二虎嘛。

#### 三、之前发生了什么?

```bash
history
#显示当前用户在终端上执行过的命令历史记录。它会列出以数字编号的命令历史列表，每条记录都包含执行的命令以及相应的编号

history 10          # 显示最近的10条命令历史记录
history -c          # 清除当前会话的命令历史记录
history -d 3        # 删除编号为3的命令历史记录
history -a          # 将当前会话的命令追加到历史记录文件中
history -n          # 不将当前会话的命令追加到历史记录文件中
```

查看一下之前服务器上执行过的命令。看一下总是没错的，加上前面看的谁登录过的信息，应该有点用。另外作为root要注意，不要利用自己的权限去侵犯别人的隐私哦。

到这里先提醒一下，等会你可能会需要更新HISTTIMEFORMAT环境变量来显示这些命令被执行的时间。对要不然光看到一堆不知道啥时候执行的命令，同样会令人抓狂的。

#### 四、现在在运行的进程是啥?

```bash
pstree -a
pstree [选项] [进程ID]
#在 Linux 系统上显示进程树（Process Tree）的实用工具。它以树状图的形式显示系统中运行的进程及其关系，使您能够更清晰地了解进程之间的父子关系和层次结构

pstree              # 显示当前进程的进程树
pstree -p           # 显示当前进程的进程树，并显示进程ID
pstree -a           # 显示当前进程的进程树，并显示命令行参数
pstree -n           # 按进程ID的数字顺序显示进程树
pstree -u           # 显示当前进程的进程树，并显示所有者（用户）
pstree 12345        # 显示进程ID为12345的进程及其子进程的进程树
```

```bash
ps -aux
```

这都是查看现有进程的。psaux的结果比较杂乱，pstree-a的结果比较简单明了，可以看到正在运行的进程及相关用户。

#### 五、监听的网络服务

```bash
netstat -ntlp
netstat -nulp
netstat -nxlp
```

```bash
netstat        # 显示活动的网络连接和监听端口
netstat -t     # 显示TCP协议的连接
netstat -u     # 显示UDP协议的连接
netstat -n     # 以数字形式显示IP地址和端口号
netstat -p     # 显示与每个连接关联的进程ID（需要管理员权限）
netstat -r     # 显示路由表信息
netstat -s     # 显示网络统计信息
netstat -l     # 仅显示监听状态的连接和监听端口
```

```bash
ss           # 显示所有网络套接字状态
ss -t        # 显示TCP协议的套接字状态
ss -u        # 显示UDP协议的套接字状态
ss -l        # 仅显示监听状态的套接字
ss -n        # 以数字形式显示IP地址和端口号
ss -p        # 显示与每个套接字关联的进程ID（需要管理员权限）
ss -r        # 显示路由表信息
```

我一般都分开运行这三个命令，不想一下子看到列出一大堆所有的服务。netstat-nalp倒也可以。

找到所有正在运行的服务，检查它们是否应该运行。查看各个监听端口。在netstat显示的服务列表中的PID和psaux进程列表中的是一样的。

如果服务器上有好几个Java或者Erlang什么的进程在同时运行，能够按PID分别找到每个进程就很重要了。

通常我们建议每台服务器上运行的服务少一点，必要时可以增加服务器。如果你看到一台服务器上有三四十个监听端口开着，那还是做个记录，回头有空的时候清理一下，重新组织一下服务器。

#### 六、CPU和内存

```bash
free -m    #以MB为单位查看内存使用情况
              total        used        free      shared  buff/cache   available
Mem:           7983        4024         624         448        3334        3086
Swap:          2047           0        2047

total：物理内存总量。
used：已使用的物理内存。
free：空闲的物理内存。
shared：被共享使用的内存。
buff/cache：用于缓存文件系统的内存（包括文件缓存和磁盘缓存）。
available：可用的内存量，即系统可以立即分配给新进程的内存量。
Swap：交换空间的总量、已使用的交换空间和空闲的交换空间
```

```bash
uptime
 16:34:12 up  1:23,  4 users,  load average: 0.15, 0.23, 0.18
#用于显示系统的运行时间和当前的负载情况。它提供了有关系统的运行时间、平均负载和当前活跃进程数的信息
16:34:12：当前系统时间。
up 1:23：系统的运行时间，格式为 "days:hours"，表示系统已经运行了 1 天 23 小时。
4 users：当前登录系统的用户数量。
load average: 0.15, 0.23, 0.18：系统的平均负载情况。这里显示了 1 分钟、5 分钟和 15 分钟的平均负载。#平均负载是指单位时间内系统处于可运行状态和不可中断状态的进程数量。负载平均值越高，表示系统的负载越重。通常，负载平均值小于 CPU 核心数量的情况下被认为是正常的
```

```bash
top  
#在 Linux 和 Unix 系统上用于实时监视系统中进程的动态情况的命令。它提供了一个交互式的界面，显示了系统中当前运行的进程的实时信息，并按照 CPU 使用率、内存占用等指标进行排序
top - 16:48:30 up 1 day,  2:32,  4 users,  load average: 0.24, 0.32, 0.18
Tasks: 206 total,   1 running, 205 sleeping,   0 stopped,   0 zombie
%Cpu(s):  5.3 us,  1.8 sy,  0.0 ni, 91.9 id,  0.9 wa,  0.0 hi,  0.1 si,  0.0 st
KiB Mem :  8098284 total,  1473452 free,  4092856 used,  2531976 buff/cache
KiB Swap:  2097148 total,  2097148 free,        0 used.  3309548 avail Mem
#%Cpu(s) 行显示了 CPU 的使用情况，包括用户空间使用、系统内核使用、空闲和等待等。
#KiB Mem 行显示了物理内存使用情况，包括总量、空闲、已使用和缓存等。
#KiB Swap 行显示了交换空间使用情况，包括总量、空闲和已使用等。
  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
  1 root      20   0  227848  12568   8812 S   0.0  0.2   0:04.07 systemd
  2 root      20    -       0      0      0 S   0.0  0.0   0:00.00 kthreadd
  3 root       0    -       0      0      0 S   0.0  0.0   0:03.26 ksoftirqd/0
  5 root       0    -       0      0      0 S   0.0  0.0   0:00.00 kworker/0:0H
  7 root       0    -       0      0      0 S   0.0  0.0   0:05.45 rcu_sched
  8 root      20    -       0      0      0 S   0.0  0.0   0:00.00 rcu_bh
  9 root      rt    -       0      0      0 S   0.0  0.0   0:00.00 migration/0
...
进程列表显示了各个进程的详细信息，包括进程 ID (PID)、用户、CPU 占用率、内存占用率、运行时间以及进程的命令行
在 top 的界面中，你可以使用键盘上的不同命令来进行操作，例如：

k：终止指定的进程。
r：修改进程的优先级。
1：显示每个 CPU 核心的详细信息。
m：按照内存占用率进行排序。
q：退出 top.
```

```bash
htop


```

注意以下问题:

还有空余的内存吗?服务器是否正在内存和硬盘之间进行swap?

还有剩余的CPU吗?服务器是几核的?是否有某些CPU核负载过多了?

服务器最大的负载来自什么地方?平均负载是多少?

#### 七、硬件

```bash
lspci
dmidecode
ethtool
```

有很多服务器还是裸机状态，可以看一下：

找到RAID卡、CPU、空余的内存插槽。根据这些情况可以大致了解硬件问题的来源和性能改进的办法。

网卡是否设置好?是否正运行在半双工状态?速度是10MBps?有没有TX/RX报错?

#### 八、IO性能

```bash
iostat -kx2
vmstat210
mpstat210
dstat--top-io--top-bio
```

这些命令对于调试后端性能非常有用。

检查磁盘使用量：服务器硬盘是否已满?

是否开启了swap交换模式(si/so)?

CPU被谁占用：系统进程?用户进程?虚拟机?

dstat用它可以看到谁在进行IO：是不是MySQL吃掉了所有的系统资源?还是你的PHP进程?

#### 九、挂载点和文件系统

```bash
mount
cat /etc/fstab
vgs
pvs
lvs
df-h
lsof +D //*bewarenottokillyourbox*/
```

一共挂载了多少文件系统?

有没有某个服务专用的文件系统?(比如MySQL?)

文件系统的挂载选项是什么：noatime?default?有没有文件系统被重新挂载为只读模式了?

磁盘空间是否还有剩余?

是否有大文件被删除但没有清空?

如果磁盘空间有问题，你是否还有空间来扩展一个分区?

#### 十、内核、中断和网络

```
sysctl -a|grep...
cat /proc/interrupts
cat /proc/net/ip_conntrack/*maytakesometimeonbusyservers*/
netstat
ss -s
```

你的中断请求是否是均衡地分配给CPU处理，还是会有某个CPU的核因为大量的网络中断请求或者RAID请求而过载了?

SWAP交换的设置是什么?对于工作站来说swappinness设为60就很好,不过对于服务器就太糟了：你最好永远不要让服务器做SWAP交换，不然对磁盘的读写会锁死SWAP进程。

conntrack_max是否设的足够大，能应付你服务器的流量?

在不同状态下(TIME_WAIT,…)TCP连接时间的设置是怎样的?

如果要显示所有存在的连接，netstat会比较慢，你可以先用ss看一下总体情况。

你还可以看一下LinuxTCPtuning了解网络性能调优的一些要点。

#### 十一、系统日志和内核消息

1.$dmesg

2.$less/var/log/messages

3.$less/var/log/secure

4.$less/var/log/auth

查看错误和警告消息，比如看看是不是很多关于连接数过多导致?

看看是否有硬件错误或文件系统错误?

分析是否能将这些错误事件和前面发现的疑点进行时间上的比对。如果你有多台机器,看起来很不方便,可以事先把日志存储在系统笔记的云日志服务器上,支持全文模糊查找,

#### 十二、定时任务

1.$ls/etc/cron*+cat

2.$foruserin$(cat/etc/passwd|cut-f1-d:);docrontab-l-u$user;done

是否有某个定时任务运行过于频繁?

是否有些用户提交了隐藏的定时任务?

在出现故障的时候，是否正好有某个备份任务在执行?

#### 十三、应用系统日志

这里边可分析的东西就多了,不过恐怕你作为运维人员是没功夫去仔细研究它的。关注那些明显的问题，比如在一个典型的LAMP(Linux+Apache+Mysql+Perl)应用环境里:

Apache&Nginx;查找访问和错误日志,直接找5xx错误,再看看是否有limit_zone错误。

这里查看了下,并没有503的,只有403的错误.所以可以跳过

MySQL;在mysql.log找错误消息，看看有没有结构损坏的表，是否有innodb修复进程在运行，是否有disk/index/query问题.

PHP-FPM;如果设定了php-slow日志,直接找错误信息(php,mysql,memcache,…)，如果没设定，赶紧设定。

Varnish;在varnishlog和varnishstat里,检查hit/miss比.看看配置信息里是否遗漏了什么规则，使最终用户可以直接攻击你的后端?

HA-Proxy;后端的状况如何?健康状况检查是否成功?是前端还是后端的队列大小达到最大值了?

结论

经过这5分钟之后，你应该对如下情况比较清楚了：

在服务器上运行的都是些啥?

这个故障看起来是和IO/硬件/网络或者系统配置(有问题的代码、系统内核调优,…)相关。

这个故障是否有你熟悉的一些特征?比如对数据库索引使用不当，或者太多的apache后台进程。